# 문제
# 항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다.
# 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.
#
# 파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.
#
# 항승이는 길이가 L인 테이프를 무한개 가지고 있다.
#
# 항승이는 테이프를 이용해서 물을 막으려고 한다.
# 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야
# 물이 다시는 안 샌다고 생각한다.
#
# 물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때,
# 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오.
# 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.
#
# 입력
# 첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다.
# 둘째 줄에는 물이 새는 곳의 위치가 주어진다.
# N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.
#
# 출력
# 첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.


# 해당 위치의 좌우 0.5씩 붙여야 함
# 4 2
# 1 2 100 101
# 1 2 2.2
# 0.5 2.5 2.7
# 0.5 1.5 1.5 2.5 99.5 100.5 100.5 101.5
# 0.5 2.5
# 0.5 2.5 99.5 101.5
# 길이가 2인 테이프 무한개를 가지고 있다.
# 물새는 곳끼리 거리 + 1 <= 테이프 길이 이면 해당 거리는 1개로 커버가능
# 물새는 곳끼리 거리 + 1 > 테이프 길이 각 각 1개씩 필요


# 더 간단히 생각하면 1에서 붙이면 테이프가 4이면
# 1에서 4까지는 한번에 수리가 가능하다.
# 4보다 작은 숫자는 탐색할 필요가 없다.
import sys

N, L = map(int, sys.stdin.readline().split())

point = list(map(int, sys.stdin.readline().split()))
point.sort()

tapeCount = 0
start = 0
for loc in point:
    if start < loc:
        start = loc+L-1
        tapeCount += 1

print(tapeCount)